# Azure DevOps Pipeline for Claim Status API
# Generates and scans container image, deploys Azure Container App & APIM configuration (placeholders)
# NOTE: Provide the following service connections / variables in pipeline settings:
#  - service connection (Azure Resource Manager) name: AZURE_SUB
#  - variable: ACR_NAME (e.g. myregistry123)
#  - variable: ACR_LOGIN_SERVER (e.g. myregistry123.azurecr.io)
#  - variable: ACA_ENV (ACA environment name)
#  - variable: ACA_NAME (Container App name)
#  - variable: RESOURCE_GROUP (resource group name)
#  - variable: OPENAI_ENDPOINT / OPENAI_DEPLOYMENT (for app settings)
#  - variable: APIM_NAME (for APIM deployment) (optional placeholder)
#  - variable: LOCATION (Azure region)
#  - variable: IMAGE_REPO (e.g. claimstatusapi)
#  - variable: VULN_FAIL_SEVERITY (e.g. High)

trigger:
  branches:
    include:
      - main

pr:
  branches:
    include:
      - main

variables:
  BUILD_CONFIGURATION: Release
  DOTNET_VERSION: '8.0.x'
  IMAGE_TAG: '$(Build.BuildId)'
  IMAGE_FULL: '$(ACR_LOGIN_SERVER)/$(IMAGE_REPO):$(IMAGE_TAG)'
  VULN_FAIL_SEVERITY: 'High'

stages:
  - stage: build
    displayName: Build & Unit Test
    jobs:
      - job: build
        pool:
          vmImage: ubuntu-latest
        steps:
          - task: UseDotNet@2
            displayName: 'Use .NET $(DOTNET_VERSION)'
            inputs:
              packageType: sdk
              version: '$(DOTNET_VERSION)'

          - task: DotNetCoreCLI@2
            displayName: Restore
            inputs:
              command: 'restore'
              projects: 'ClaimStatusApi.sln'

          - task: DotNetCoreCLI@2
            displayName: Build
            inputs:
              command: 'build'
              projects: 'ClaimStatusApi.sln'
              arguments: '--configuration $(BUILD_CONFIGURATION)'

          # (Optional) Add tests if/when present
          # - task: DotNetCoreCLI@2
          #   displayName: Test
          #   inputs:
          #     command: 'test'
          #     projects: 'tests/**/*.csproj'
          #     arguments: '--configuration $(BUILD_CONFIGURATION) --collect "XPlat Code Coverage"'

          - publish: $(System.DefaultWorkingDirectory)/src/ClaimStatusApi/bin/$(BUILD_CONFIGURATION)/net8.0
            artifact: drop

  - stage: container
    displayName: Build & Push Image
    dependsOn: build
    jobs:
      - job: docker
        pool:
          vmImage: ubuntu-latest
        steps:
          - checkout: self
            clean: true

          - task: AzureCLI@2
            displayName: 'Azure CLI: Login'
            inputs:
              azureSubscription: 'AZURE_SUB'
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                echo "Logged in."

          - task: Bash@3
            displayName: 'Docker Build'
            inputs:
              targetType: inline
              script: |
                docker build -t $(IMAGE_FULL) .

          - task: Bash@3
            displayName: 'Docker Push'
            inputs:
              targetType: inline
              script: |
                az acr login -n $(ACR_NAME)
                docker push $(IMAGE_FULL)

          # Defender for Cloud will auto-scan after push. Poll for vulnerability summary.
          - task: Bash@3
            name: vulnscan
            displayName: 'Check ACR Vulnerabilities (Gate)' 
            inputs:
              targetType: inline
              script: |
                echo "Waiting for vulnerability scan result..."
                REPO=$(IMAGE_REPO)
                TAG=$(IMAGE_TAG)
                # Poll up to 10 times
                for i in {1..10}; do
                  echo "Attempt $i: fetching vulnerabilities..."
                  az acr manifest show-vulnerabilities --only-show-base-image-vulnerabilities false \
                    --registry $(ACR_NAME) --repository $REPO --tag $TAG --output json > vulns.json 2>/dev/null || true
                  if grep -q 'scanStatus' vulns.json; then
                    STATUS=$(jq -r '.scanStatus' vulns.json)
                    echo "Status: $STATUS"
                    if [ "$STATUS" = "Completed" ]; then
                      break
                    fi
                  fi
                  sleep 15
                done
                if [ ! -f vulns.json ]; then
                  echo "No vulnerability report found"; exit 1
                fi
                echo "Vulnerability summary:"; cat vulns.json | jq '.summary'
                # Count high / critical
                HIGH=$(jq -r '.summary.high | select(.!=null)' vulns.json || echo 0)
                CRIT=$(jq -r '.summary.critical | select(.!=null)' vulns.json || echo 0)
                echo "High: $HIGH Critical: $CRIT"
                # Fail gate logic
                if [ "$VULN_FAIL_SEVERITY" = "High" ] && { [ "$HIGH" -gt 0 ] || [ "$CRIT" -gt 0 ]; }; then
                  echo "Failing due to High/Critical vulnerabilities"; exit 1; fi
                if [ "$VULN_FAIL_SEVERITY" = "Critical" ] && [ "$CRIT" -gt 0 ]; then
                  echo "Failing due to Critical vulnerabilities"; exit 1; fi
                echo "Vulnerability gate passed"

          - publish: vulns.json
            artifact: vulnerabilityReport

  - stage: deploy
    displayName: Deploy ACA & APIM
    dependsOn: container
    condition: succeeded()
    jobs:
      - job: deploy
        pool:
          vmImage: ubuntu-latest
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: 'Deploy / Update Container App'
            inputs:
              azureSubscription: 'AZURE_SUB'
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                set -e
                echo "Deploying Container App $(ACA_NAME) in $(RESOURCE_GROUP)"
                # Create Container App (idempotent)
                az containerapp create \
                  --name $(ACA_NAME) \
                  --resource-group $(RESOURCE_GROUP) \
                  --environment $(ACA_ENV) \
                  --image $(IMAGE_FULL) \
                  --ingress external \
                  --target-port 8080 \
                  --min-replicas 1 --max-replicas 2 \
                  --query "id" || az containerapp update --name $(ACA_NAME) --resource-group $(RESOURCE_GROUP) --image $(IMAGE_FULL)

                # Update secrets / env (OpenAI endpoint & deployment)
                az containerapp secret set --name $(ACA_NAME) --resource-group $(RESOURCE_GROUP) \
                  --secrets openai-endpoint=$(OPENAI_ENDPOINT) openai-deployment=$(OPENAI_DEPLOYMENT)
                az containerapp update --name $(ACA_NAME) --resource-group $(RESOURCE_GROUP) \
                  --set-env-vars OpenAI__Endpoint=secretref:openai-endpoint OpenAI__Deployment=secretref:openai-deployment

          # Placeholder for APIM configuration (import OpenAPI from running app or apply policy files)
          - task: AzureCLI@2
            displayName: 'Configure APIM (placeholder)'
            inputs:
              azureSubscription: 'AZURE_SUB'
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                set -e
                if [ -z "$(APIM_NAME)" ]; then
                  echo "APIM_NAME not set; skipping APIM configuration"; exit 0; fi
                echo "Configuring APIM $(APIM_NAME)"
                # Discover Container App FQDN
                FQDN=$(az containerapp show -n $(ACA_NAME) -g $(RESOURCE_GROUP) --query properties.configuration.ingress.fqdn -o tsv)
                echo "Container App FQDN: $FQDN"
                # Import / upsert API from live swagger
                az apim api import --resource-group $(RESOURCE_GROUP) --service-name $(APIM_NAME) \
                  --path claims --api-id claims-api --specification-url https://$FQDN/swagger/v1/swagger.json --protocols https || true
                # Apply global API policy
                az apim api policy apply --resource-group $(RESOURCE_GROUP) --service-name $(APIM_NAME) \
                  --api-id claims-api --format rawxml --policy-file apim/api-policy.xml
                # Map operationIds to policies
                az apim api operation policy apply --resource-group $(RESOURCE_GROUP) --service-name $(APIM_NAME) \
                  --api-id claims-api --operation-id GetClaimById --format rawxml --policy-file apim/get-claim-operation-policy.xml || true
                az apim api operation policy apply --resource-group $(RESOURCE_GROUP) --service-name $(APIM_NAME) \
                  --api-id claims-api --operation-id SummarizeClaim --format rawxml --policy-file apim/post-summarize-operation-policy.xml || true
                echo "APIM configuration complete"

          - task: Bash@3
            displayName: 'Output Deployment Info'
            inputs:
              targetType: inline
              script: |
                echo "IMAGE: $(IMAGE_FULL) deployed to ACA $(ACA_NAME)"

# End of pipeline
